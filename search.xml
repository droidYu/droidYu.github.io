<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【学习笔记】之《第一行代码(第3版)》(Kotlin部分)</title>
      <link href="/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Kotlin%E9%83%A8%E5%88%86/"/>
      <url>/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Kotlin%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于《第一行代码(第3版)》包含了Android基础和Kotlin两部分知识，故笔者将笔记分为两篇：<br><a href="https://droidyu.github.io/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Android%E9%83%A8%E5%88%86/">【学习笔记】之《第一行代码(第3版)》(Android部分)</a><br><a href="https://droidyu.github.io/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Kotlin%E9%83%A8%E5%88%86/">【学习笔记】之《第一行代码(第3版)》(Kotlin部分)</a></p></blockquote><h1 id="Kotlin基础"><a href="#Kotlin基础" class="headerlink" title="Kotlin基础"></a>Kotlin基础</h1><h2 id="Kotlin的发展历程"><a href="#Kotlin的发展历程" class="headerlink" title="Kotlin的发展历程"></a>Kotlin的发展历程</h2><ul><li><p>2011年，JetBrains发布了Kotlin的第一个版本，并在2012年将其开源。</p></li><li><p>2016年Kotlin发布了1.0正式版，代表着Kotlin语言已经足够成熟和稳定了，并且JetBrains也在自家的旗舰IDE开发工具IntelliJ IDEA中加入了Kotlin的支持。</p></li><li><p>2017年Google宣布Kotlin正式成为Android开发一级语言，并且Android Studio也加入了对Kotlin的支持。</p></li><li><p>2019年Google正式宣布了Kotlin First，未来提供的官方API也将会以Kotlin版本为主。</p></li></ul><h2 id="Kotlin相比于Java的优势"><a href="#Kotlin相比于Java的优势" class="headerlink" title="Kotlin相比于Java的优势"></a>Kotlin相比于Java的优势</h2><ul><li><p>语法更加简洁，对于同样的功能，使用Kotlin开发的代码量可能会比使用Java开发的减少50%甚至更多。</p></li><li><p>语法更加高级，相比于Java比较老旧的语法，Kotlin增加了很多现代高级语言的语法特性，使得开发效率大大提升。</p></li><li><p>语言更加安全，Kotlin几乎杜绝了空指针这个全球崩溃率最高的异常。</p></li><li><p>和Java是100%兼容的，Kotlin可以直接调用使用Java编写的代码，也可以无缝使用Java第三方的开源库。这使得Kotlin在加入了诸多新特性的同时，还继承了Java的全部财富。</p></li></ul><h2 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>val（value的简写的简写）用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应Java中的final变量。</li><li>var（variable的简写的简写）用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值复制，对应Java中的非final变量。</li></ul><table><thead><tr><th>Java基本数据类型</th><th>Kotlin对象数据类型</th><th>数据类型说明</th></tr></thead><tbody><tr><td>int</td><td>Int</td><td>整型</td></tr><tr><td>long</td><td>Long</td><td>长整型</td></tr><tr><td>short</td><td>Short</td><td>短整型</td></tr><tr><td>float</td><td>Float</td><td>单精度浮点型</td></tr><tr><td>double</td><td>Double</td><td>双精度浮点型</td></tr><tr><td>boolean</td><td>Boolean</td><td>布尔型</td></tr><tr><td>char</td><td>Char</td><td>字符型</td></tr><tr><td>byte</td><td>Byte</td><td>字节型</td></tr></tbody></table><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>定义一个函数的语法规则如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;      <span class="keyword">return</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>当一个函数的函数体中只有一行代码时，可以使用单行代码函数的语法糖：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>Kotlin中的if语句相比于Java有一个额外的功能：它是可以有返回值的，返回值就是if语句每一个条件中最后一行代码的返回值。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;    <span class="keyword">val</span> value = <span class="keyword">if</span> (num1 &gt; num2) &#123;        num1    &#125; <span class="keyword">else</span> &#123;        num2    &#125;    <span class="keyword">return</span> value&#125;</span><br></pre></td></tr></table></figure><p>仔细观察上述代码，你会发现value其实是一个多余的变量，我们可以直接将if语句返回，这样代码将会变得更加精简，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;    <span class="keyword">return</span> <span class="keyword">if</span> (num1 &gt; num2) &#123;        num1    &#125; <span class="keyword">else</span> &#123;        num2    &#125;&#125;</span><br></pre></td></tr></table></figure><p>当一个函数只有一行代码时，可以省略函数体部分，直接将这一行代码使用等号串连在函数定义的尾部。虽然largerNumber()函数不止只有一行代码，但是它和只有一行代码的作用是相同的，只是return了一下if语句的返回值而已，符合该语法糖的使用条件。那么我们就可以将代码进一步精简：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (num1 &gt; num2) &#123;    num1&#125; <span class="keyword">else</span> &#123;    num2&#125;</span><br></pre></td></tr></table></figure><p>最后，还可以将上述代码再精简一下，直接压缩成一行代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (num1 &gt; num2) num1 <span class="keyword">else</span> num2</span><br></pre></td></tr></table></figure><h3 id="when条件语句"><a href="#when条件语句" class="headerlink" title="when条件语句"></a>when条件语句</h3><p>当需要判断的条件非常多的时候，可以考虑使用when语句来替代if语句。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (name) &#123;    <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span>    <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span>    <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span>    <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span>    <span class="keyword">else</span> -&gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>除了精确匹配之外，when语句还允许进行类型匹配。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span> &#123;    <span class="keyword">when</span> (num) &#123;        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;number is Int&quot;</span>)        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;number is Double&quot;</span>)        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;number not support&quot;</span>)    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="for-in循环语句"><a href="#for-in循环语句" class="headerlink" title="for-in循环语句"></a>for-in循环语句</h3><p>我们可以使用如下Kotlin代码来表示一个区间：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0.</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>上述代码表示创建了一个0到10的区间，并且两端都是闭区间，这意味着0到10这两个端点都是包含在区间中的，用数学的方式表达出来就是[0, 10]。</p><p>也可以使用until关键字来创建一个左闭右开的区间：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0</span> until <span class="number">10</span></span><br></pre></td></tr></table></figure><p>上述代码表示创建了一个0到10的左闭右开区间，它的数学表达方式是[0, 10)。有了区间之后，我们就可以通过for-in循环来遍历这个区间：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;        println(i)    &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果你想跳过其中的一些元素，可以使用step关键字：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span> step <span class="number">2</span>) &#123;        println(i)    &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果你想创建一个降序的区间，可以使用downTo关键字：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>) &#123;        println(i)    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>可以使用如下代码定义一个类，以及声明它所拥有的字段和函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span>    <span class="keyword">var</span> age = <span class="number">0</span>    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;        println(name + <span class="string">&quot; is eating. He is &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>)    &#125;&#125;</span><br></pre></td></tr></table></figure><p>然后使用如下代码创建对象，并对对象进行操作：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">val</span> p = Person()    p.name = <span class="string">&quot;Jack&quot;</span>    p.age = <span class="number">19</span>    p.eat()&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Kotlin中一个类默认是不可以被继承的，如果想要让一个类可以被继承，需要主动声明open关键字：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    …&#125;</span><br></pre></td></tr></table></figure><p>要让另一个类去继承Person类，则需要使用冒号关键字： </p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;    <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span>    <span class="keyword">var</span> grade = <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>现在Student类中就自动拥有了Person类中的字段和函数，还可以定义自己独有的字段和函数。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>Kotlin中定义接口的关键字和Java中是相同的，都是使用的interface：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span>    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span>&#125;</span><br></pre></td></tr></table></figure><p>而Kotlin中实现接口的关键字变量了冒号，和继承使用的是同样的关键字：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) : Study &#123;    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span> &#123;        println(name + <span class="string">&quot; is reading.&quot;</span>)    &#125;    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span> &#123;        println(name + <span class="string">&quot; is doing homework.&quot;</span>)    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><h2 id="Lambda编程"><a href="#Lambda编程" class="headerlink" title="Lambda编程"></a>Lambda编程</h2><h3 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h3><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h3 id="集合的函数式API"><a href="#集合的函数式API" class="headerlink" title="集合的函数式API"></a>集合的函数式API</h3><h3 id="Java函数式API"><a href="#Java函数式API" class="headerlink" title="Java函数式API"></a>Java函数式API</h3><h2 id="空指针检查"><a href="#空指针检查" class="headerlink" title="空指针检查"></a>空指针检查</h2><h3 id="空指针检查-1"><a href="#空指针检查-1" class="headerlink" title="空指针检查"></a>空指针检查</h3><h3 id="可空类型系统"><a href="#可空类型系统" class="headerlink" title="可空类型系统"></a>可空类型系统</h3><h3 id="判空辅助工具"><a href="#判空辅助工具" class="headerlink" title="判空辅助工具"></a>判空辅助工具</h3><h2 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h2><h3 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h3><h3 id="函数的参数默认值"><a href="#函数的参数默认值" class="headerlink" title="函数的参数默认值"></a>函数的参数默认值</h3><h1 id="标准函数和静态方法"><a href="#标准函数和静态方法" class="headerlink" title="标准函数和静态方法"></a>标准函数和静态方法</h1><h1 id="延迟初始化和密封类"><a href="#延迟初始化和密封类" class="headerlink" title="延迟初始化和密封类"></a>延迟初始化和密封类</h1><h1 id="扩展函数和运算符重载"><a href="#扩展函数和运算符重载" class="headerlink" title="扩展函数和运算符重载"></a>扩展函数和运算符重载</h1><h1 id="高阶函数详解"><a href="#高阶函数详解" class="headerlink" title="高阶函数详解"></a>高阶函数详解</h1><h1 id="高阶函数的应用"><a href="#高阶函数的应用" class="headerlink" title="高阶函数的应用"></a>高阶函数的应用</h1><h1 id="泛型和委托"><a href="#泛型和委托" class="headerlink" title="泛型和委托"></a>泛型和委托</h1><h1 id="使用infix函数构建更可读的语法"><a href="#使用infix函数构建更可读的语法" class="headerlink" title="使用infix函数构建更可读的语法"></a>使用infix函数构建更可读的语法</h1><h1 id="范型的高级特性"><a href="#范型的高级特性" class="headerlink" title="范型的高级特性"></a>范型的高级特性</h1><h1 id="使用协程编写高效的并发程序"><a href="#使用协程编写高效的并发程序" class="headerlink" title="使用协程编写高效的并发程序"></a>使用协程编写高效的并发程序</h1><h1 id="编写好用的工具方法"><a href="#编写好用的工具方法" class="headerlink" title="编写好用的工具方法"></a>编写好用的工具方法</h1><h1 id="使用DSL构建专有的语法结构"><a href="#使用DSL构建专有的语法结构" class="headerlink" title="使用DSL构建专有的语法结构"></a>使用DSL构建专有的语法结构</h1><p>Java与Kotlin代码之间的转换</p><p>（持续更新中。。。）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 《第一行代码(第3版)》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】之《第一行代码(第3版)》(Android部分)</title>
      <link href="/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Android%E9%83%A8%E5%88%86/"/>
      <url>/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Android%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于《第一行代码(第3版)》包含了Android基础和Kotlin两部分知识，故笔者将笔记分为两篇：<br><a href="https://droidyu.github.io/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Android%E9%83%A8%E5%88%86/">【学习笔记】之《第一行代码(第3版)》(Android部分)</a><br><a href="https://droidyu.github.io/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Kotlin%E9%83%A8%E5%88%86/">【学习笔记】之《第一行代码(第3版)》(Kotlin部分)</a></p></blockquote><h1 id="开始启程，你的第一行Android代码"><a href="#开始启程，你的第一行Android代码" class="headerlink" title="开始启程，你的第一行Android代码"></a>开始启程，你的第一行Android代码</h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><p><img src="https://pic.imgdb.cn/item/61ed33632ab3f51d9139a269.png"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>所有安装在手机上的应用程序都是属于这一层，比如系统自带的联系人、短信等程序。</p><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><p>这一层主要提供了构建应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。</p><h3 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h3><p>这一层通过一些C/C++库来为Android系统提供了主要的特性支持。在这一层还包括Android运行时库和Dalvik虚拟机（5.0系统之后改为ART），它使得每个Android应用都能运行在独立的进程中，并拥有一个自己的虚拟机实例。<br>相较于JVM，Dalvik和ART是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。</p><h3 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h3><p>Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。</p><h1 id="探究新语言，快速入门Kotlin编程"><a href="#探究新语言，快速入门Kotlin编程" class="headerlink" title="探究新语言，快速入门Kotlin编程"></a>探究新语言，快速入门Kotlin编程</h1><p>详见<a href="https://droidyu.github.io/notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81(%E7%AC%AC%E4%B8%89%E7%89%88)Kotlin%E9%83%A8%E5%88%86/">【学习笔记】之《第一行代码(第3版)》(Kotlin部分)</a></p><h1 id="先从看得见的入手，探究Activity"><a href="#先从看得见的入手，探究Activity" class="headerlink" title="先从看得见的入手，探究Activity"></a>先从看得见的入手，探究Activity</h1><h1 id="软件也要拼脸蛋，UI开发的点点滴滴"><a href="#软件也要拼脸蛋，UI开发的点点滴滴" class="headerlink" title="软件也要拼脸蛋，UI开发的点点滴滴"></a>软件也要拼脸蛋，UI开发的点点滴滴</h1><h1 id="手机平板要兼顾，探究Fragment"><a href="#手机平板要兼顾，探究Fragment" class="headerlink" title="手机平板要兼顾，探究Fragment"></a>手机平板要兼顾，探究Fragment</h1><h1 id="全局大喇叭，详解广播机制"><a href="#全局大喇叭，详解广播机制" class="headerlink" title="全局大喇叭，详解广播机制"></a>全局大喇叭，详解广播机制</h1><h1 id="数据库存储全方案，详解持久化技术"><a href="#数据库存储全方案，详解持久化技术" class="headerlink" title="数据库存储全方案，详解持久化技术"></a>数据库存储全方案，详解持久化技术</h1><h1 id="跨程序共享数据，探究ContentProvider"><a href="#跨程序共享数据，探究ContentProvider" class="headerlink" title="跨程序共享数据，探究ContentProvider"></a>跨程序共享数据，探究ContentProvider</h1><h1 id="丰富你的程序，运用手机多媒体"><a href="#丰富你的程序，运用手机多媒体" class="headerlink" title="丰富你的程序，运用手机多媒体"></a>丰富你的程序，运用手机多媒体</h1><h1 id="后台默默的劳动者，探究Service"><a href="#后台默默的劳动者，探究Service" class="headerlink" title="后台默默的劳动者，探究Service"></a>后台默默的劳动者，探究Service</h1><h1 id="看看精彩的世界，使用网络技术"><a href="#看看精彩的世界，使用网络技术" class="headerlink" title="看看精彩的世界，使用网络技术"></a>看看精彩的世界，使用网络技术</h1><h1 id="最佳的UI体验，MaterialDesign实战"><a href="#最佳的UI体验，MaterialDesign实战" class="headerlink" title="最佳的UI体验，MaterialDesign实战"></a>最佳的UI体验，MaterialDesign实战</h1><h1 id="高级程序开发组件，探究Jetpack"><a href="#高级程序开发组件，探究Jetpack" class="headerlink" title="高级程序开发组件，探究Jetpack"></a>高级程序开发组件，探究Jetpack</h1><h1 id="继续进阶，你还应该掌握的高级技巧"><a href="#继续进阶，你还应该掌握的高级技巧" class="headerlink" title="继续进阶，你还应该掌握的高级技巧"></a>继续进阶，你还应该掌握的高级技巧</h1><h1 id="进入实战，开发一个天气预报App"><a href="#进入实战，开发一个天气预报App" class="headerlink" title="进入实战，开发一个天气预报App"></a>进入实战，开发一个天气预报App</h1><h1 id="编写并发布一个开源库，PermissionX"><a href="#编写并发布一个开源库，PermissionX" class="headerlink" title="编写并发布一个开源库，PermissionX"></a>编写并发布一个开源库，PermissionX</h1><p>（持续更新中。。。）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 《第一行代码(第3版)》 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
