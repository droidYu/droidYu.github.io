<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式（三）工厂方法模式</title>
      <link href="/DesignPattern/factory-method/"/>
      <url>/DesignPattern/factory-method/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p><p>简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。上篇文章<a href="https://droidyu.github.io/DesignPattern/simple-factory/">《设计模式（二）简单工厂模式》</a>讲了简单工厂模式，我们今天就来看一下工厂方法模式。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式的结构图如下所示：</p><p><img src="https://pic.imgdb.cn/item/621998f92ab3f51d916520a6.jpg"></p><ul><li><code>AbstractFactory</code>：抽象工厂类，提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li><code>Factory</code>：工厂类，负责实现创建所有实例的内部逻辑。创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li><code>AbstractProduct</code>：抽象产品类，这是简单工厂模式所创建的所有对象的父类。</li><li><code>Product</code>：具体产品类，继承自抽象产品类。</li></ul><p>下面用代码来实现一下：</p><ol><li>创建抽象产品</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建具体产品</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OppoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OPPO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VivoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;VIVO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建抽象工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>具体工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OppoFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OppoPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VivoFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VivoPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>调用工厂创建产品</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone oppoPhone = <span class="keyword">new</span> OppoFactory().createPhone();</span><br><span class="line">        oppoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone vivoPhone = <span class="keyword">new</span> VivoFactory().createPhone();</span><br><span class="line">        vivoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone xiaomiPhone = <span class="keyword">new</span> XiaomiFactory().createPhone();</span><br><span class="line">        xiaomiPhone.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6210d9f22ab3f51d919d3512.jpg"></p><p>打印日志可以看到这种品牌的手机都启动了。至此，我们就完成了工厂方法模式的创建。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于每个具体产品对应一个具体工厂，所以会产生很多类，而且每次创建产品都需要<code>new</code>一个工厂出来，对系统的性能有一定的影响。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>为了更好的管理工厂类，而且让工厂类可重用，我们可以创建一个工厂的工厂，使用<code>HashMap</code>来对工厂进行缓存，在使用工厂时直接从<code>HashMap</code>获取缓存的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactoryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">        oppo, vivo, xiaomi</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;PhoneType, PhoneFactory&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(PhoneType.oppo, <span class="keyword">new</span> OppoFactory());</span><br><span class="line">        map.put(PhoneType.vivo, <span class="keyword">new</span> VivoFactory());</span><br><span class="line">        map.put(PhoneType.xiaomi, <span class="keyword">new</span> XiaomiFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneFactory <span class="title">getFactory</span><span class="params">(PhoneType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone oppoPhone = PhoneFactoryFactory.getFactory(PhoneFactoryFactory.PhoneType.oppo).createPhone();</span><br><span class="line">        oppoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone vivoPhone = PhoneFactoryFactory.getFactory(PhoneFactoryFactory.PhoneType.vivo).createPhone();</span><br><span class="line">        vivoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone xiaomiPhone = PhoneFactoryFactory.getFactory(PhoneFactoryFactory.PhoneType.xiaomi).createPhone();</span><br><span class="line">        xiaomiPhone.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6210d9f22ab3f51d919d3512.jpg"><br>从日志可以看到各种品牌的手机同样是启动了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>优点：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li></ul><p>缺点：</p><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li></ul><p><strong>示例代码已上传至<a href="https://github.com/droidYu/DesignPattern/blob/main/app/src/main/java/com/droidyu/designpattern/factory/method/FactoryMethod.java">Github</a></strong></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（二）简单工厂模式</title>
      <link href="/DesignPattern/simple-factory/"/>
      <url>/DesignPattern/simple-factory/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p><p>简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。我们今天就来看一下简单工厂模式。</p><h1 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h1><p>定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>简而言之就是在使用一个具体对象的时候，我们不直接<code>new</code>一个对象，而是通过一个单独的工厂类来<code>new</code>这个对象。</p><p>简单工厂模式的结构图如下所示：</p><p><img src="https://pic.imgdb.cn/item/621324532ab3f51d91458fcf.jpg"></p><ul><li><code>Factory</code>：工厂类，负责实现创建所有实例的内部逻辑。创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li><code>AbstractProduct</code>：抽象产品类，这是简单工厂模式所创建的所有对象的父类。</li><li><code>Product</code>：具体产品类，继承自抽象产品类。</li></ul><p>我们以生产手机为例，用代码来实现一下：</p><p>（1）<strong>抽象产品类</strong></p><p>创建一个手机的抽象产品类，其有一个抽象方法用于启动手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<strong>具体产品类</strong></p><p>我们创建各种品牌的手机，他们都继承自父类<code>Phone</code>，并实现了启动的方法。具体分为oppo手机，vivo手机和小米手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OppoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OPPO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VivoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;VIVO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）<strong>工厂类</strong></p><p>我们创建一个手机工厂，用来生产各种手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">createPhone</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;oppo&quot;</span>:</span><br><span class="line">                phone = <span class="keyword">new</span> OppoPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;vivo&quot;</span>:</span><br><span class="line">                phone = <span class="keyword">new</span> VivoPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;xiaomi&quot;</span>:</span><br><span class="line">                phone = <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）<strong>调用工厂类生产手机并启动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PhoneFactory.createPhone(<span class="string">&quot;oppo&quot;</span>).start();</span><br><span class="line">    PhoneFactory.createPhone(<span class="string">&quot;vivo&quot;</span>).start();</span><br><span class="line">    PhoneFactory.createPhone(<span class="string">&quot;xiaomi&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6210d9f22ab3f51d919d3512.jpg"></p><p>打印日志可以看到这种品牌的手机都启动了。至此，我们就完成了简单工厂模式的创建。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>简单工厂模式的问题在于如果后续有其他品牌的手机需要生产，那我们就要修改工厂的<code>if-else</code>语句，如果逻辑简单还好，但在实际开发中，<code>if-else</code>的代码块逻辑可能很复杂，稍有疏忽就容易制造出成吨的<code>bug</code>。那如何解决这样的问题呢？我们可以利用泛型和反射来优化我们的简单工厂。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>对于普通的简单工厂，需要维护好传入的生产需求和具体生产的对象的关系，根据需求生产具体产品。有没有什么一劳永逸的方法呢？当然有，我们可以创建一个万能的自动化工厂，传入什么类型的产品，工厂就生产什么样的产品。工厂内部的逻辑不需要根据传入的产品变更而更改。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T extends Phone&gt; <span class="function">T <span class="title">createPhone</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            phone = (Phone) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>方法中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AutoPhoneFactory.createPhone(OppoPhone.class).start();</span><br><span class="line">    AutoPhoneFactory.createPhone(VivoPhone.class).start();</span><br><span class="line">    AutoPhoneFactory.createPhone(XiaomiPhone.class).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6210d9f22ab3f51d919d3512.jpg"><br>从日志可以看到各种品牌的手机同样是启动了，而且对于新增的品牌，我们无需修改工厂类，只需传入新增品牌的<code>.class</code>就可以创建对应的实例对象了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>使用场景</strong>：</p><ul><li>工厂类负责创建的对象较少；</li><li>客户只需要知道传入工厂类的参数，而无需关心创建对象的逻辑。</li></ul><p><strong>优点</strong>：</p><ul><li>使用户根据参数获得对应的类实例，避免直接实例化类，降低了耦合性。</li></ul><p><strong>缺点</strong>：</p><ul><li>可实例化的类型在编译期间已经被确定。如果增加新类型，需要修改工厂，违背了开放封闭原则；</li><li>使用简单工厂需要知道所要生成的类型，当子类过多或子类层次过多时不适合使用简单工厂模式；</li><li>对于使用泛型和反射优化的简单工厂类，因为使用了泛型创建实例，其性能有一定的问题，所以虽然做到了新增产品类不用修改工厂，但是在大量创建实例时，性能有一定损耗。</li></ul><p><strong>示例代码已上传<a href="https://github.com/droidYu/DesignPattern/blob/main/app/src/main/java/com/droidyu/designpattern/factory/simple/SimpleFactory.java">Github</a></strong></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级特性（二）注解处理 之 3分钟写半个Retrofit框架</title>
      <link href="/Java/annotation-processor-1/"/>
      <url>/Java/annotation-processor-1/</url>
      
        <content type="html"><![CDATA[<p>上篇文章<a href="https://droidyu.github.io/Java/annotation/">《Java高级特性（一）注解的分类及使用》</a>讲了注解相关的基础知识，但是基本的注解声明和使用，并不能发挥注解的真正效果。如果要让注解产生实际的作用，就需要搭配注解处理器来使用。至于为什么说写半个<code>Retrofit</code>框架，因为本文只涉及到<code>Retrofit</code>框架中关于注解处理的内容（大佬轻喷）。</p><p>我们先回顾一下<code>Retrofit</code>是怎么用的？（代码摘自<a href="https://square.github.io/retrofit/"><code>Retrofit</code>官网</a>）</p><p>第一步：定义一个接口，接口里面定义方法，使用<code>@GET、@POST</code>等注解标注我们定义的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path(&quot;user&quot;)</span> String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：创建<code>retrofit</code>实例，然后调用<code>retrofit.create()</code>方法，将我们定义的接口<code>.class</code>传入<code>create</code>方法。通过<code>create</code>方法生成实现了我们定义的接口的代理对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><p>第三步：调用实现了接口的代理对象的具体方法，完成网络请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">&quot;octocat&quot;</span>);</span><br></pre></td></tr></table></figure><p>那<code>Retrofit</code>是如何将<code>@GET</code>注解里的接口地址解析出来并使用的呢？这里就用到了注解处理，使用反射的方式获取了方法的注解传入的参数值。下面我们就自己用代码来实现一下。</p><ol><li>定义一个<code>@GET</code>注解和<code>@POST</code>注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> POST &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义<code>Api</code>抽象类，类比<code>Retrofit</code>的第一步：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(&quot;https://api.github.com&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getGithub</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;https://api.github.com/droidYu&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">updateUserInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Retrofit</code>涉及到动态代理到知识，这里不进行深入讲解，所以我们使用了抽象类来代替<code>Retrofit</code>的接口。</p><ol start="3"><li>在<code>main</code>方法中调用<code>getAnnotation()</code>方法，并传入<code>Api.class</code>，这一步可以类比<code>Retrofit</code>框架中第二步<code>retrofit.create(GitHubService.class)</code>方法的调用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        getAnnotation(Api.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>getAnnotation</code>方法中通过反射到方式获取<code>@GET</code>和<code>@POST</code>注解里的请求地址并打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAnnotation</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取传入的.class中的所有方法</span></span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">//遍历获取到到方法数组，获取每个方法中的所有注解</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="comment">//遍历获取到的所有注解，判断注解类型，分别打印注解内容</span></span><br><span class="line">            <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">                print(<span class="string">&quot;GET&quot;</span>,method,((GET) annotation).value());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">                print(<span class="string">&quot;POST&quot;</span>,method,((POST) annotation).value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>print</code>方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String methodType,Method method, String annotationValue)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;从 &quot;</span>+methodType+<span class="string">&quot; 方法：&quot;</span>+method.getName()+<span class="string">&quot; 获取到注解的值：&quot;</span> + annotationValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：<br><img src="https://pic.imgdb.cn/item/620f86a52ab3f51d910992b3.jpg"></p><p>从打印的内容中，我们可以看到，我们已经成功的从我们自己定义的注解中获取到了请求地址。这其实就是<code>Retrofit</code>框架用注解获取请求地址的的核心设计思路，只不过<code>Retrofit</code>框架的这部分代码更加完善，使得框架非常的简单易用。至此，我们花3分钟的时间，就写了半个<code>Retrofit</code>框架，即<code>Retrofit</code>注解处理的核心代码。</p><p>示例代码已上传<a href="https://github.com/droidYu/JavaDemo/tree/main/app/src/main/java/com/droidyu/javademo/annotation/processor">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级特性（一）注解的分类及使用</title>
      <link href="/Java/annotation/"/>
      <url>/Java/annotation/</url>
      
        <content type="html"><![CDATA[<h1 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h1><p>注解分为标准注解和元注解</p><h2 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h2><p>标准注解有以下几种：</p><ul><li><code>@Override</code>：对覆盖超类中的方法进行标注，如果被标注的方法并没有实际覆盖超类中的方法，编译器会发错错误警告。</li><li><code>@Deprecated</code>：对不鼓励使用或已过时的方法进行标注，当开发人员对这些被标注的方法进行调用时，会显示该方法已过时的提示信息。</li><li><code>@SuppressWarnings</code>：选择性的取消特定代码段中的警告。</li><li><code>@SafeVarargs</code>：JDK 7 新增的注解，用来声明使用了可变长度参数的方法，其在与泛型类一起使用时会出现类型安全问题。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是用来标注注解的注解，在注解定义时使用。有以下几种：</p><ul><li><code>@Targe</code>：标注所修饰的对象范围。</li><li><code>@Inherited</code>：表示注解可以被继承。</li><li><code>@Documented</code>：表示注解应该被JavaDoc工具记录。</li><li><code>@Retention</code>：用来声明注解的保留策略。</li><li><code>@Repeatable</code>：JDK 8 新增的注解，允许一个注解在同一声明类型（类、属性或方法）中多次使用。</li></ul><p>下面重点介绍下<code>@Targe</code>注解及<code>@Retention</code>注解：</p><h3 id="Targe注解"><a href="#Targe注解" class="headerlink" title="@Targe注解"></a><code>@Targe</code>注解</h3><p>其中<code>@Targe</code>注解的取值是一个<code>ElementType</code>类型的数值。这里有以下几种取值，对应不用的对象范围。</p><ul><li><code>ElementType.TYPE</code>：声明类、接口或枚举类型。</li><li><code>ElementType.FIELD</code>：声明成员变量。</li><li><code>ElementType.METHOD</code>：声明方法。</li><li><code>ElementType.PARAMETER</code>：声明参数。</li><li><code>ElementType.CONSTRUCTOR</code>：声明构造方法。</li><li><code>ElementType.LOCAL_VARIABLE</code>：声明局部变量。</li><li><code>ElementType.ANNOTATION_TYPE</code>：声明注解类型。</li><li><code>ElementType.PACKAGE</code>：声明包。</li><li><code>ElementType.TYPE_PARAMETER</code>：声明参数类型。</li><li><code>ElementType.TYPE_USE</code>：使用类型。</li><li><code>ElementType.MODULE</code>：声明模块。</li></ul><h3 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a><code>@Retention</code>注解</h3><p><code>@Retention</code>注解有3种类型，分别表示不同级别的保留策略。</p><ul><li><code>RetentionPolicy.SOURCE</code>：源码级注解。注解信息只保留在<code>.java</code>源码中。源码在编译后，注解信息被丢弃，不会保留在<code>.class</code>中。</li><li><code>RetentionPolicy.CLASS</code>：编译时注解。注解信息会保留在<code>.java</code>源码以及<code>.class</code>中。当运行Java程序时，JVM会丢弃该注解信息，不会保留在JVM中。</li><li><code>RetentionPolicy.RUNTIME</code>：运行时注解。当运行Java程序时，JVM也会保留该注解信息，可以通过反射获取该注解信息。</li></ul><h1 id="注解的定义和使用"><a href="#注解的定义和使用" class="headerlink" title="注解的定义和使用"></a>注解的定义和使用</h1><h2 id="基本定义和使用"><a href="#基本定义和使用" class="headerlink" title="基本定义和使用"></a>基本定义和使用</h2><p>定义新的注解类型使用<code>@interface</code>关键字，这与定义一个接口很像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义完成后，就可以在程序中使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解成员变量的定义和使用"><a href="#注解成员变量的定义和使用" class="headerlink" title="注解成员变量的定义和使用"></a>注解成员变量的定义和使用</h2><p>注解只有成员变量，没有方法。注解的成员变量在注解定义中以“无参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了<code>name</code>和<code>age</code>两个成员变量，使用该注解时就要给两个成员变量指定值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(name = &quot;droidYu&quot;,age = 0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在定义成员变量时，用<code>default</code>关键字为其指定默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;droidYu&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span>  0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时就可以不进行赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义成员变量时，有个一特殊的成员变量<code>value</code>，在使用时可以不用写 <code>value = </code>，而直接传入<code>value</code>的值即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;droidYu&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span>  0</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;no value&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>value=</code>可以省略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;no value&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用元注解定义注解"><a href="#使用元注解定义注解" class="headerlink" title="使用元注解定义注解"></a>使用元注解定义注解</h2><p>定义注解时，还可以为注解添加元注解，例如使用<code>@Target</code>和<code>@Retention</code>元注解来定义只能用来注解方法的运行时注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMethod &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的<code>MyMethod</code>注解就只能标注在方法上，如果标注在类上，编译器就会提示错误警告，编译不能通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;no value&quot;)</span></span><br><span class="line"><span class="meta">@MyMethod</span> <span class="comment">//这里会报错，编译不能通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyMethod</span> <span class="comment">//正确的使用位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码已上传<a href="https://github.com/droidYu/JavaDemo/tree/main/app/src/main/java/com/droidyu/javademo/annotation">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（二）Java内存模型</title>
      <link href="/Java/thread/volatile/"/>
      <url>/Java/thread/volatile/</url>
      
        <content type="html"><![CDATA[<p>Java 内存模型（JMM）是一种抽象的概念，并不真实存在，它描述了一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。JVM中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此它存在可见性问题。Java内存模型定义了线程和主存间的抽象关系：线程之间的共享变量存储在主存中，每个线程有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。需要注意的是本地内存是Java内存模型的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器等区域。Java内存模型的抽象示意图如下所示：</p><p><img src="https://pic.imgdb.cn/item/620e47ab2ab3f51d9164947f.jpg"></p><p>线程A与线程B要通信的话，要经历下面两个步骤：</p><ol><li>线程A把线程A本地内存中更新过的内存共享变量刷新到主存；</li><li>线程B到主存中取线程A之前更新过的共享变量。</li></ol><p>所以我们在执行下面语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>语句所在的线程会对变量i所在的缓存进行赋值操作，然后再写入主存中，而不是直接将数值0写入主存。</p><p>为了有个直观的感受，我们用一段代码来实现一下。先定义一个类<code>VolatileDemo</code>，包含一个<code>running</code>字段和一个<code>stop</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileDemo demo = <span class="keyword">new</span> VolatileDemo();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (demo.running) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        demo.stop();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>方法，即主线程中创建<code>VolatileDemo</code>对象实例，然后新创建一个子线程，进入<code>while</code>循环不断的判断<code>running</code>属性。我们让主线程<code>sleep</code>1000毫秒，然后执行<code>stop</code>更新<code>running</code>的值为<code>false</code>，按正常逻辑如果<code>running = false</code>的话，子线程就会执行完，打印<code>end</code>，然后整个程序执行完毕。我们运行程序看一下：<br><img src="https://pic.imgdb.cn/item/620e514f2ab3f51d9172c4a6.jpg"></p><p>发现子线程并没有打印<code>end</code>，并且程序一直在运行，没有结束退出。说明主线程更新的<code>running = false</code>，子线程并不知道。</p><p>示例代码已上传<a href="https://github.com/droidYu/JavaDemo/blob/main/app/src/main/java/com/droidyu/javademo/thread/volatile_demo/VolatileDemo.java">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（一）线程状态及线程创建方式</title>
      <link href="/Java/thread/status-and-create/"/>
      <url>/Java/thread/status-and-create/</url>
      
        <content type="html"><![CDATA[<p>Java多线程编程作为每一个Android Coder都必须掌握的技术，今天我们就来聊一聊关于Java多线程的点点滴滴。Android沿用了Java的线程模型，一个Android应用创建时会开启一个线程，这个线程就是我们熟知的主线程，也叫UI线程。如果我们在主线程直接进行网络请求，系统会直接报错，提示不能在主线程请求网络，至于问什么，是因为网络访问是一个耗时的操作，如果网络访问很慢，就会导致ANR（Application Not Response），从Android3.0开始，系统就要求网络访问必须在子线程中进行，否则就会抛出异常。</p><p>关于线程和进程的描述以及二者的关系，网络上一搜一大把，这里就不再赘述，我们主要来看一下线程的各种状态。</p><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><ul><li><strong>New</strong>：新创建状态。线程被创建，还没调用<code>start</code>方法。</li><li><strong>Runnable</strong>：可运行状态。一旦调用了<code>start</code>方法，线程就处于Runnable状态。</li><li><strong>Blocked</strong>：阻塞状态。线程被锁阻塞。</li><li><strong>Waiting</strong>：等待状态。线程暂时不活动，也不运行任何代码，直到线程调度器重新激活它。</li><li><strong>Timed waiting</strong>：超时等待状态。和等待状态不同的是，它可以在指定的时间自行返回。</li><li><strong>Terminated</strong>：终止状态。表示当前线程已经执行完毕。有两种情况可以进入终止状态：一是<code>run</code>方法执行完毕正常退出，二是因为没有捕获的异常而终止了<code>run</code>方法，导致线程终止。<br>各种状态的关系以及流转如下图所示：<br><img src="https://pic.imgdb.cn/item/620c9caa2ab3f51d91e1189e.jpg"></li></ul><h1 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h1><p>线程的创建一般有3种方式，其中前两种最常用，但在日常开发中建议尽量不要自己手动创建线程，因为自己创建的线程难以管理，且如果线程很多的话性能会受到一定的影响。推荐使用<code>Executor</code>相关的线程池框架管理线程。</p><p>需要注意的是调用<code>start</code>方法后并不是立即执行线程中的代码，而是使线程进入可运行状态，至于什么时候运行是由操作系统决定的。</p><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello MyThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello MyRunnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello MyCallable&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">    Future&lt;String&gt; future = service.submit(myCallable);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，程序通过3种方式创建了线程，并打印了运行结果：<br><img src="https://pic.imgdb.cn/item/620cadbf2ab3f51d9105d8e1.jpg"></p><p>源码已上传到<a href="https://github.com/droidYu/JavaDemo/blob/main/app/src/main/java/com/droidyu/javademo/thread/create/ThreadCreate.java">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（十一）View的draw流程</title>
      <link href="/android/view/11-view-draw/"/>
      <url>/android/view/11-view-draw/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/6-view-work-entrance/">《View体系（六）View工作流程入口》</a>提到<code>View</code>的工作流程包括了<code>measure</code>、<code>layout</code>和<code>draw</code>的过程，今天我们就来看一下<code>View</code>的<code>draw</code>流程是怎样的。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p><code>View</code>的<code>draw</code>流程很简单，源码里的注释官方也写的很清楚，我们看<code>View</code>的<code>draw</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    drawBackground(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 2, save the canvas&#x27; layers</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    onDraw(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">    drawDefaultFocusHighlight(canvas);</span><br></pre></td></tr></table></figure><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>官方注释已经清楚的写了每一步的工作：</p><ol><li>如果需要，则绘制背景（<code>drawBackground</code>）</li><li>保存当前canvas层</li><li>绘制View的内容（<code>onDraw</code>）</li><li>绘制子View（<code>dispatchDraw</code>）</li><li>如果需要，则绘制View的褪色边缘，类似于阴影效果</li><li>绘制装饰，比如滚动条（<code>onDrawForeground</code>）</li><li>绘制默认焦点高亮效果（<code>drawDefaultFocusHighlight</code>）</li></ol><blockquote><p><strong>注释中说明了第2步和第5步可以跳过，这里就不展开讲解，在此重点分析其他步骤。</strong></p></blockquote><h1 id="步骤1：绘制背景"><a href="#步骤1：绘制背景" class="headerlink" title="步骤1：绘制背景"></a>步骤1：绘制背景</h1><p>进入<code>View</code>的<code>drawBackground</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    ...</span><br><span class="line">    setBackgroundBounds();  <span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    background.draw(canvas);    <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>注释1处设置背景范围，注释2处通过<code>Drawable</code>的<code>draw</code>方法来绘制背景，关于<code>Drawable</code>将在后面的文章详细讲解。看注释1的<code>setBackgroundBounds</code>是如何设置背景范围的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBackgroundBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackgroundSizeChanged &amp;&amp; mBackground != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackground.setBounds(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);    <span class="comment">//1</span></span><br><span class="line">        mBackgroundSizeChanged = <span class="keyword">false</span>;</span><br><span class="line">        rebuildOutline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到注释1处通过<code>View</code>的<code>mRight、mLeft、mBottom、mTop</code>等参数调用<code>mBackground.setBounds</code>方法来进行绘制范围的设置。</p><h1 id="步骤2：保存当前canvas层"><a href="#步骤2：保存当前canvas层" class="headerlink" title="步骤2：保存当前canvas层"></a>步骤2：保存当前canvas层</h1><h1 id="步骤3：绘制View的内容"><a href="#步骤3：绘制View的内容" class="headerlink" title="步骤3：绘制View的内容"></a>步骤3：绘制View的内容</h1><p>步骤3调用了<code>View</code>的<code>onDraw</code>方法，这个方法是一个空实现，因为不同的<code>View</code>有不同的内容，所以需要我们自己去实现，即在自定义<code>View</code>时重写该方法来实现我们自己的绘制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="步骤4：绘制子View"><a href="#步骤4：绘制子View" class="headerlink" title="步骤4：绘制子View"></a>步骤4：绘制子View</h1><p>步骤4调用了<code>dispatchDraw</code>方法，这个方法也是个空实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewGroup</code>重写了这个方法，我们看<code>ViewGroup</code>的<code>dispatchDraw</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        more |= drawChild(canvas, transientChild, drawingTime);</span><br></pre></td></tr></table></figure><p>源码很长，这里只贴出关键代码，在<code>dispatchDraw</code>方法中遍历子<code>View</code>并调用<code>drawChild</code>方法，我们继续看<code>drawChild</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>drawChild</code>方法实际就是调用了子<code>View</code>的<code>draw</code>方法对子<code>View</code>进行绘制</p><h1 id="步骤5：绘制View的阴影效果"><a href="#步骤5：绘制View的阴影效果" class="headerlink" title="步骤5：绘制View的阴影效果"></a>步骤5：绘制View的阴影效果</h1><h1 id="步骤6：绘制装饰"><a href="#步骤6：绘制装饰" class="headerlink" title="步骤6：绘制装饰"></a>步骤6：绘制装饰</h1><p>步骤6调用了<code>onDrawForeground</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawForeground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    onDrawScrollIndicators(canvas);</span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Drawable foreground = mForegroundInfo != <span class="keyword">null</span> ? mForegroundInfo.mDrawable : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (foreground != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> Rect selfBounds = mForegroundInfo.mSelfBounds;</span><br><span class="line">            <span class="keyword">final</span> Rect overlayBounds = mForegroundInfo.mOverlayBounds;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;</span><br><span class="line">                selfBounds.set(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selfBounds.set(getPaddingLeft(), getPaddingTop(),</span><br><span class="line">                        getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ld = getLayoutDirection();</span><br><span class="line">            Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),</span><br><span class="line">                    foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);</span><br><span class="line">            foreground.setBounds(overlayBounds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foreground.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是对<code>ScrollBar</code>及其它装饰进行绘制。</p><h1 id="步骤7：绘制默认焦点高亮效果"><a href="#步骤7：绘制默认焦点高亮效果" class="headerlink" title="步骤7：绘制默认焦点高亮效果"></a>步骤7：绘制默认焦点高亮效果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawDefaultFocusHighlight</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDefaultFocusHighlight != <span class="keyword">null</span> &amp;&amp; isFocused()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultFocusHighlightSizeChanged) &#123;</span><br><span class="line">            mDefaultFocusHighlightSizeChanged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> l = mScrollX;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> r = l + mRight - mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> t = mScrollY;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> b = t + mBottom - mTop;</span><br><span class="line">            mDefaultFocusHighlight.setBounds(l, t, r, b);</span><br><span class="line">        &#125;</span><br><span class="line">        mDefaultFocusHighlight.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（十）从LinearLayout分析View的布局流程</title>
      <link href="/android/view/10-view-layout/"/>
      <url>/android/view/10-view-layout/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/6-view-work-entrance/">《View体系（六）View工作流程入口》</a>提到<code>View</code>的工作流程包括了<code>measure</code>、<code>layout</code>和<code>draw</code>的过程，上两篇文章<a href="https://droidyu.github.io/android/view/8-view-measure/">《View体系（八）深入剖析View的onMeasure方法》</a>和<a href="https://droidyu.github.io/android/view/9-ViewGroup-measure/">《View体系（九）从LinearLayout分析ViewGroup的测量流程》</a>分别对<code>View</code>和<code>ViewGroup</code>的<code>measure</code>过程做了分析，今天我们就来看一下<code>View</code>的<code>layout</code>过程是怎样的。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>先看<code>View</code>的<code>layout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    onLayout(changed, l, t, r, b);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><code>layout</code>方法很长，这里只贴出关键代码。<code>layout</code>的4个参数<code>l、t、r、b</code>分别代表<code>View</code>从左上右下相对父容器的距离。注释1处根据不同情况会调用<code>setOpticalFrame</code>或<code>setFrame</code>方法，而在<code>setOpticalFrame</code>方法内部也会调用到<code>setFrame</code>，所以我们直接看<code>setFrame</code>做了什么，进入<code>setFrame</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Assign a size and position to this view.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            mLeft = left;</span><br><span class="line">            mTop = top;</span><br><span class="line">            mRight = right;</span><br><span class="line">            mBottom = bottom;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从注释（<code>Assign a size and position to this view.</code>）可以看出，这个方法是为<code>View</code>分配了大小和位置。<code>setFrame</code>将传进来的4个参数分别初始化<code>mLeft、mTop、mRight、mBottom</code>这4个值，这样就确定了该<code>View</code>在父容器的位置。</p><p>接着看上段代码注释2处，可以看到<code>layout</code>内部调用了<code>onLayout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onLayout</code>是一个空方法，这样设计和<code>ViewGroup</code>中没有<code>onMeasure</code>方法类似，确定位置时不同的控件有不同的实现，所以<code>onLayout</code>需要由具体的控件自己来实现如何布局。所以在<code>View</code>和<code>ViewGroup</code>中都没有实现<code>onLayout</code>方法，我们还是以<code>LinearLayout</code>为例来分析<code>onLayout</code>方法，进入<code>LinearLayout</code>的<code>onLayout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        layoutVertical(l, t, r, b);<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHorizontal(l, t, r, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和测量流程一样，这里根据<code>mOrientation</code>进行不同的布局流程，以纵向布局为例，会进入注释1处<code>layoutVertical</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();   <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;   <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childTop += measureNullChild(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                    (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                gravity = minorGravity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</span><br><span class="line">                            + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                childTop += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            childTop += lp.topMargin;</span><br><span class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                    childWidth, childHeight);   <span class="comment">//3</span></span><br><span class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);   <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处获取子<code>View</code>的数量，注释2处循环遍历子<code>View</code> 并调用注释3处的<code>setChildFrame</code>方法确定子<code>View</code>的位置，注释4处对<code>childTop</code>不断进行累加，这样子<code>View</code>才会依次按垂直方向一个接一个的排列下去，而不是堆叠在一起，接着看注释3处的<code>setChildFrame</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    child.layout(left, top, left + width, top + height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部调用了子<code>View</code>的<code>layout</code>方法来确定自己的位置，<code>layout</code>方法文章开头已经讲过，这里不再赘述。<br>至此，就完成了<code>LinearLayout</code>的<code>layout</code>过程。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（九）从LinearLayout分析ViewGroup的测量流程</title>
      <link href="/android/view/9-ViewGroup-measure/"/>
      <url>/android/view/9-ViewGroup-measure/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/8-view-measure/">《View体系（八）深入剖析View的onMeasure方法》</a>我们深入分析了<code>View</code>的<code>onMeasure</code>方法，我们今天就来看一下<code>ViewGroup</code>的测量流程。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>在<code>View</code>做测量时，会调用<code>View</code>的<code>onMeasure</code>方法，但是我们翻看<code>ViewGroup</code>的源码，并没有发现<code>onMeasure</code>方法，难道<code>ViewGroup</code>不用测量？显然不是，我们换一个类来看，<code>LinearLayout</code>继承自<code>ViewGroup</code>，我们从<code>LinearLayout</code>的源码中找到了熟悉的<code>onMeasure</code>方法，我们看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;<span class="comment">//1</span></span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br></pre></td></tr></table></figure><p>注释1处根据<code>mOrientation</code>判断是横向排列还是纵向排列来进入不同的测量流程，我们以纵向排列为例，看<code>LinearLayout</code>是如何测量其高度的，进入注释2处的<code>measureVertical</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mTotalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">                measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                        heightMeasureSpec, usedHeight);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();<span class="comment">//4</span></span><br><span class="line">                <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                    lp.height = <span class="number">0</span>;</span><br><span class="line">                    consumedExcessSpace += childHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>由于<code>measureVertical</code>方法很长，这里只贴出部分关键代码。注释1处获取子<code>View</code>的数量，注释2处遍历子<code>View</code>并根据测量模式进入不同的<code>if-else</code>分支，这里以<code>wrap_content</code>为例（即<code>AT_MOST</code>模式），则进入<code>else</code>分支，注释3处对子<code>View</code>进行测量，注释4处获取测量到的子<code>View</code>的高度，注释5处对子<code>View</code>的测量结果进行累加作为最终<code>LinearLayout</code>的测量高度。我们进入注释3的<code>measureChildBeforeLayout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureChildBeforeLayout</span><span class="params">(View child, <span class="keyword">int</span> childIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> totalWidth, <span class="keyword">int</span> heightMeasureSpec,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> totalHeight)</span> </span>&#123;</span><br><span class="line">    measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class="line">            heightMeasureSpec, totalHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进入<code>measureChildWithMargins</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处调用了<code>child.measure</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br></pre></td></tr></table></figure><p>而<code>measure</code>又调用了<code>View</code>的<code>onMeasure</code>方法，对于<code>View</code>的<code>onMeasure</code>方法，之前的文章<a href="https://droidyu.github.io/android/view/8-view-measure/">《View体系（八）深入剖析View的onMeasure方法》</a>已经讲过，这里不再赘述。</p><p>至此<code>LinearLayout</code>的测量已经很清楚了，即对于纵向的<code>LinearLayout</code>并指定高度为<code>wrap_content</code>来说，是通过遍历测量子<code>View</code>的高度并累加作为自己的高度。至于为什么<code>ViewGroup</code>没有<code>onMeasure</code>方法，是因为它无法统一究竟要以什么方式来测量，所以它要让它的子类来各自实现测量方法，最终它的子类又重写<code>onMeasure</code>完成对自己的测量。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(一)单例模式</title>
      <link href="/DesignPattern/singleton/"/>
      <url>/DesignPattern/singleton/</url>
      
        <content type="html"><![CDATA[<p>单例设计模式（<code>Singleton Design Pattern</code>）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式结构图如下：<br><img src="https://pic.imgdb.cn/item/6205cd2e2ab3f51d910e2d98.jpg"></p><p><code>Client</code>为客户端，<code>Singleton</code>为单例类，<code>Client</code>通过调用<code>Singleton.getInstance()</code>方法获取实例对象。</p><p>下面介绍常见的6种单例写法：</p><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><p>饿汉式的实现方式比较简单。在类加载的时候，<code>instance</code> 静态实例就已经创建并初始化好了，所以，<code>instance</code> 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 <code>instance</code> 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p><h1 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h1><p>有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现单例是线程不安全的，因为在多线程的时候可能会重复创建单例，导致实例全局不唯一。一般使用下面的方式，即使用<code>synchronized</code>关键字来保证线程安全。</p><h1 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 <code>getInstance()</code> 这个方法加了一把大锁（<code>synchronzed</code>），导致这个函数的并发度很低。如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p><h1 id="双重检查模式（DCL）"><a href="#双重检查模式（DCL）" class="headerlink" title="双重检查模式（DCL）"></a>双重检查模式（DCL）</h1><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法在<code>getSingleton</code>方法中对<code>singleton</code>进行了两次判空，第一次是为了不必要的同步，第二次是在<code>singleton</code>等于<code>null</code>的情况下才创建实例。<br>在这里使用<code>volatile</code>会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。 <code>DCL</code>优点是资源利用率高，第一次执行<code>getInstance</code>时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。</p><h1 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h1><p><code>SingletonHolder</code> 是一个静态内部类，当外部类 <code>Singleton</code> 被加载的时候，并不会创建 <code>SingletonHolder</code> 实例对象。只有当调用 <code>getInstance()</code> 方法时，<code>SingletonHolder</code> 才会被加载，这个时候才会创建 <code>instance</code>。<code>instance</code> 的唯一性、创建过程的线程安全性，都由 <code>JVM</code> 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>单例的定义单例设计模式（<code>Singleton Design Pattern</code>）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</li><li>单例的用处从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</li><li>单例的实现单例有下面几种经典的实现方式。</li></ol><ul><li> 饿汉式<br>饿汉式的实现方式，在类加载的期间，就已经将 <code>instance</code> 静态实例初始化好了，所以，<code>instance</code> 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</li><li>懒汉式<br>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</li><li>双重检测<br>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 <code>instance</code> 被创建之后，再调用 <code>getInstance()</code> 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</li><li>静态内部类<br>利用 <code>Java</code> 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</li><li>枚举<br>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 <code>Java</code> 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</li></ul><p>6种单例的实现代码见<a href="https://github.com/droidYu/DesignPattern/tree/main/app/src/main/java/com/droidyu/designpattern/singleton">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（八）深入剖析View的onMeasure方法</title>
      <link href="/android/view/8-view-measure/"/>
      <url>/android/view/8-view-measure/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/6-view-work-entrance/">《View体系（六）View工作流程入口》</a>介绍了<code>View</code>是从什么地方开始它的工作流程的，<a href="https://droidyu.github.io/android/view/7-view-MeasureSpec/">《View体系（七）理解 MeasureSpec》</a>介绍了<code>View</code>在<code>measure</code>流程时的一个重要参数。有了上两篇的铺垫，我们就来看一下<code>View</code>的<code>onMeasure</code>方法到底做了什么。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>在<code>View</code>做测量时，会调用<code>View</code>的<code>onMeasure</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只调用了一个<code>setMeasuredDimension</code>方法，看它的注释：</p><blockquote><p>This method must be called by {@link #onMeasure(int, int)} to store the measured width and measured height. </p></blockquote><p>可以知道，这个方法是用来存储测量的宽度和测量的高度的。</p><p>继续看<code>setMeasuredDimension</code>方法里面调用了<code>getDefaultSize</code>，该方法用于获取<code>View</code>默认的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;<span class="comment">//①</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>specMode</code>和<code>specSize</code>之前的文章中讲过，表示测量模式和测量大小。这段代码表示根据不同的<code>specMode</code>来返回不同的<code>result</code>值，即<code>View</code>测量的大小。可以看到注释<code>①</code>处不管是<code>AT_MOST</code>还是<code>EXACTLY</code>，都返回<code>specSize</code>，也就是说，对于一个直接继承自<code>View</code>的自定义<code>View</code>来说，它的<code>wrap_content</code>和<code>match_parent</code>属性的效果是一样的。因此我们自定义<code>View</code>时，如果要使<code>wrap_content</code>属性生效，就必须重写<code>onMeasure</code>方法并根据<code>specMode</code>来返回指定的大小。</p><p>现在我们知道了<code>specSize</code>是测量的大小，那传入的第一个参数<code>size</code>又是个什么？我们看传入的<code>getSuggestedMinimumWidth</code>方法做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先判断<code>View</code>是否有背景，如果有，就返回背景宽度和<code>View</code>最小宽度中较大的一个；如果没有，就直接返回<code>View</code>的最小宽度，即<code>mMinWidth</code>。默认的<code>mMinWidth</code>为0，对应<code>xml</code>文件中的<code>android:minWidth</code>属性。</p><p>至此，<code>View</code>的<code>onMeasure</code>方法我们就分析完了，其做的工作很简单，就是保存<code>View</code>的测量尺寸。在我们自定义<code>View</code>时，我们根据自己的需求来重写<code>onMeasure</code>方法，并对<code>View</code>的尺寸自己进行测量并调用<code>setMeasuredDimension</code>方法进行保存。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Android系统启动过程</title>
      <link href="/android/framework/system-launch/"/>
      <url>/android/framework/system-launch/</url>
      
        <content type="html"><![CDATA[<p><code>Android</code>系统的启动流程是十分复杂的，但是作为应用层的开发人员来说，了解其大致流程即可。</p><h1 id="启动流程概览"><a href="#启动流程概览" class="headerlink" title="启动流程概览"></a>启动流程概览</h1><p><code>Android</code>系统启动流程大致可以概括为以下的几个步骤：</p><ol><li><p>启动电源及系统启动</p></li><li><p>引导程序<code>BootLoader</code>启动</p></li><li><p><code>Linux</code>内核启动</p></li><li><p><code>init</code>进程启动</p></li><li><p><code>Zygote</code>进程启动</p></li><li><p><code>SystemServer</code>进程启动</p></li><li><p><code>Launcher</code>启动</p></li></ol><h1 id="关键进程"><a href="#关键进程" class="headerlink" title="关键进程"></a>关键进程</h1><p>在介绍启动流程之前，先来了解一下几个关键的进程及其作用：</p><h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a><code>init</code>进程</h2><p><code>init</code>进程是<code>Android</code>系统中用户空间的第一个进程，进程号为<code>1</code>，是<code>Android</code>系统启动流程中的一个关键进程。它被赋予很多重要的工作职责，比如创建<code>Zygote</code>（孵化器）和属性服务等。<br><code>init</code>进程是由多个源文件组成的，这些文件位于源码目录<code>system/core/init</code>中。</p><h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a><code>Zygote</code>进程</h2><p>在<code>Android</code>系统中，<code>DVM</code>和<code>ART</code>、应用程序进程以及运行系统关键服务的<code>SystemServer</code>进程都是由<code>Zygote</code>进程来创建的，我们也可以将其称为孵化器。它通过<code>fork</code>（复制进程）的形式来创建应用程序进程和<code>SystemServer</code>进程。由于<code>Zygote</code>进程在启动时会创建<code>DVM</code>或<code>ART</code>，因此通过<code>fork</code>而创建的应用程序进程和<code>SystemServer</code>进程可以在内部获得一个<code>DVM</code>或<code>ART</code>的实例副本。</p><h2 id="SystemServer进程"><a href="#SystemServer进程" class="headerlink" title="SystemServer进程"></a><code>SystemServer</code>进程</h2><p><code>SystemServer</code>进程主要用于创建系统服务，我们熟悉的<code>AMS</code>、<code>WMS</code>和<code>PMS</code>都是由它来创建的。</p><h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a><code>Launcher</code></h2><p><code>Launcher</code>是一个应用程序，用来显示系统中已经安装的应用程序。<code>Launcher</code>在启动过程中会请求<code>PMS</code>返回系统中已安装的应用程序信息，并将这些信息封装为一个快捷图标列表显示在系统屏幕上，用户可以点击这些图标来启动相应的应用程序。</p><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><h2 id="1-启动电源及系统启动"><a href="#1-启动电源及系统启动" class="headerlink" title="1. 启动电源及系统启动"></a>1. 启动电源及系统启动</h2><p>当电源按下时，引导芯片代码从预定义的地方（固化在<code>ROM</code>中）开始执行。这里主要做的是加载引导程序<code>BootLoader</code>到<code>RAM</code>中，然后执行引导程序。</p><h2 id="2-引导程序BootLoader启动"><a href="#2-引导程序BootLoader启动" class="headerlink" title="2. 引导程序BootLoader启动"></a>2. 引导程序<code>BootLoader</code>启动</h2><p>引导程序<code>BootLoader</code>是在<code>Android</code>操作系统开始运行前到一小段程序，它的作用是把系统<code>OS</code>拉起来并运行。</p><h2 id="3-Linux内核启动"><a href="#3-Linux内核启动" class="headerlink" title="3. Linux内核启动"></a>3. <code>Linux</code>内核启动</h2><p>当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当<code>Linux</code>内核完成系统设置时，它首先在系统中寻找<code>init.rc</code>文件，并启动<code>init</code>进程。</p><h2 id="4-init进程启动"><a href="#4-init进程启动" class="headerlink" title="4. init进程启动"></a>4. <code>init</code>进程启动</h2><ul><li>创建和挂载启动所需的文件目录</li><li>初始化和启动属性服务</li><li>解析<code>init.rc</code>配置文件</li><li>启动<code>Zygote</code>进程</li></ul><h2 id="5-Zygote进程启动"><a href="#5-Zygote进程启动" class="headerlink" title="5. Zygote进程启动"></a>5. <code>Zygote</code>进程启动</h2><ul><li>创建<code>AppRuntime</code>并调用其<code>start</code>方法，启动<code>Zygote</code>进程</li><li>创建<code>Java</code>虚拟机并为其注册<code>JNI</code>方法</li><li>通过<code>JNI</code>调用<code>ZygoteInit</code>的<code>main</code>函数进入<code>Zygote</code>的<code>Java</code>框架层</li><li>通过<code>registerZygoteSocket</code>方法创建服务端<code>Socket</code>，并通过<code>runSelectLoop</code>方法等待<code>AMS</code>的请求来创建新的应用程序进程。</li></ul><h2 id="6-SystemServer进程启动"><a href="#6-SystemServer进程启动" class="headerlink" title="6. SystemServer进程启动"></a>6. <code>SystemServer</code>进程启动</h2><ul><li>启动<code>Binder</code>线程池，用于后续与其他进程进行通信</li><li>创建<code>SystemServiceManager</code>，用于对系统服务进行创建、启动和管理。</li><li>启动各种系统服务<h2 id="7-Launcher启动"><a href="#7-Launcher启动" class="headerlink" title="7. Launcher启动"></a>7. <code>Launcher</code>启动</h2></li></ul><p>被<code>SystemServer</code>进程启动的AMS会启动<code>Launcher</code>，<code>Launcher</code>启动后会将已安装应用的图标显示到界面上。</p><p>结合上面的流程，给出<code>Android</code>系统启动流程图：<br><img src="https://pic.imgdb.cn/item/62038ad72ab3f51d912547a8.jpg"></p><p>参考资料：《Android进阶解密》</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android系统启动 </tag>
            
            <tag> Android Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（七）理解 MeasureSpec</title>
      <link href="/android/view/7-view-MeasureSpec/"/>
      <url>/android/view/7-view-MeasureSpec/</url>
      
        <content type="html"><![CDATA[<p><code>MeasureSpec</code>是<code>View</code>的内部类，<code>MeasureSpec</code> 封装了从父级传递到子级的测量要求。每个 <code>MeasureSpec</code> 代表对宽度或高度的要求。 <code>MeasureSpec</code> 由大小和模式两部分组成。</p><p>更详细的说明请看 <a href="https://developer.android.google.cn/reference/android/view/View.MeasureSpec">Google官方文档</a></p><p>下面是<code>MeasureSpec</code>的源码：<strong>（基于<a href="https://github.com/droidYu/platform_frameworks_base/blob/android12-release/core/java/android/view/View.java"><code>Android 12</code></a>）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="meta">@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1)</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="meta">@MeasureSpecMode</span> <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + mode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = getSize(measureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</span><br><span class="line">            <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        size += delta;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Log.e(VIEW_LOG_TAG, <span class="string">&quot;MeasureSpec.adjust: new size would be negative! (&quot;</span> + size +</span><br><span class="line">                    <span class="string">&quot;) spec: &quot;</span> + toString(measureSpec) + <span class="string">&quot; delta: &quot;</span> + delta);</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mode = getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;MeasureSpec: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mode == UNSPECIFIED)</span><br><span class="line">            sb.append(<span class="string">&quot;UNSPECIFIED &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == EXACTLY)</span><br><span class="line">            sb.append(<span class="string">&quot;EXACTLY &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == AT_MOST)</span><br><span class="line">            sb.append(<span class="string">&quot;AT_MOST &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sb.append(mode).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(size);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，它代表了32位<code>int</code>值，其中高2位代表<code>mode</code>，低30位代表<code>size</code>。<code>mode</code>指测量模式，<code>size</code>指测量值。<code>mode</code>有3种模式：</p><ul><li><p><code>UNSPECIFIED</code>：未指定模式，父<code>View</code>没有对子<code>View</code>施加任何限制。它可以是任何它想要的大小。</p></li><li><p><code>EXACTLY</code>：精确模式，父<code>View</code>已经确定了子<code>View</code>的确切尺寸。无论子<code>View</code>想要多大，都将获得这些界限。</p></li><li><p><code>AT_MOST</code>：最大模式，子<code>View</code>可以根据需要达到指定的最大的大小。</p></li></ul><p><code>makeMeasureSpec</code>用来保存宽和高的信息，<code>getMode</code>用来获取测量模式，<code>getSize</code>用来获取测量大小。</p><p><code>MeasureSpec</code>受自身<code>LayoutParams</code>和父<code>View</code>的<code>MeasureSpec</code>共同影响。作为顶层<code>View</code>的<code>DecorView</code>来说，其并没有父<code>View</code>，那它的<code>MeasureSpec</code>是如何得来的呢？我们回到<code>ViewRootImpl</code>的<code>performTraversals</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mStopped || wasReportNextDraw) &#123;</span><br><span class="line"><span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">        || mHeight != host.getMeasuredHeight() || dispatchApplyInsets ||</span><br><span class="line">        updatedConfiguration) &#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">&quot;Ooops, something changed!  mWidth=&quot;</span></span><br><span class="line">            + mWidth + <span class="string">&quot; measuredWidth=&quot;</span> + host.getMeasuredWidth()</span><br><span class="line">            + <span class="string">&quot; mHeight=&quot;</span> + mHeight</span><br><span class="line">            + <span class="string">&quot; measuredHeight=&quot;</span> + host.getMeasuredHeight()</span><br><span class="line">            + <span class="string">&quot; dispatchApplyInsets=&quot;</span> + dispatchApplyInsets);</span><br><span class="line"></span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>再看注释1处的<code>getRootMeasureSpec</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数<code>windowSize</code>指窗口的尺寸，所以对于<code>DecorView</code>来说，它的<code>MeasureSpec</code>由自身的<code>LayoutParams</code>和窗口的尺寸决定，这一点和普通的<code>View</code>是不同的。<br>再回到上面看注释2处的<code>performMeasure</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;measure&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处调用了<code>mView.measure</code>方法，进入了<code>view</code>的<code>measure</code>流程。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（六）View工作流程入口</title>
      <link href="/android/view/6-view-work-entrance/"/>
      <url>/android/view/6-view-work-entrance/</url>
      
        <content type="html"><![CDATA[<p><code>View</code>的工作流程，就是<code>View</code>进行<code>measure</code>、<code>layout</code>和<code>draw</code>的过程，本篇文章我们就来一起看一下<code>View</code>是如何开始他的工作流程的。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>在上篇文章<a href="https://droidyu.github.io/android/view/5-setContentView/">《View体系（五）熟悉又陌生的setContentView》</a>中我们讲过<code>Activity</code>的结构，包括了<code>Activity</code>、<code>PhoneWindow</code>及<code>DecorView</code>。讲了<code>PhoneWindow</code>的创建和<code>DecorView</code>的创建，但此时<code>DecorView</code>还没有加载到<code>PhoneWindow</code>中，下面我们就从源码看一下<code>DecorView</code>是如何加载到<code>PhoneWindow</code>中的。</p><p>当我们调用<code>Activity</code>的<code>startActivity</code>时，最终会调用到<code>ActivityThread</code>的<code>handleLaunchActivity</code>，代码如下：</p><blockquote><p>android.app.ActivityThread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);<span class="comment">//1</span></span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>注释1处调用<code>performLaunchActivity</code>创建了一个<code>Activity</code>，进入<code>performLaunchActivity</code>方法：</p><blockquote><p>android.app.ActivityThread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">Activity activity = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);<span class="comment">//1</span></span><br><span class="line">...                </span><br><span class="line">activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken, r.shareableActivityToken);<span class="comment">//2</span></span><br><span class="line">...                    </span><br><span class="line">mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);<span class="comment">//3</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> activity;</span><br></pre></td></tr></table></figure><p>注释1处会通过<code>mInstrumentation</code>的<code>newActivity</code>方法，使用反射的方式，创建<code>Activity</code>的实例，注释2处调用<code>activity.attach</code>方法，在之前的文章中讲过，<code>attach</code>会创建<code>PhoneWindow</code>实例，并赋值给传入的<code>window</code>引用，注释3处最终会调用<code>Activity</code>的<code>OnCreate</code>回调方法，进而调用<code>setContentView</code>方法，创建<code>DecorView</code>。</p><p>在<code>Android12</code>的源码中，<code>handleLaunchActivity</code>方法中并不会直接调用<code>handleResumeActivity</code>方法，而是通过<code>ClientTransaction</code>类来实现调用<code>handleLaunchActivity</code>之后再调用<code>handleResumeActivity</code>，具体的放在后面的文章中讲解。</p><p>我们继续看<code>handleResumeActivity</code>方法：</p><blockquote><p>android.app.ActivityThread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            View decor = r.window.getDecorView();<span class="comment">//1</span></span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            ViewManager wm = a.getWindowManager();<span class="comment">//2</span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    wm.addView(decor, l);<span class="comment">//3</span></span><br><span class="line">                    ...</span><br></pre></td></tr></table></figure><p>注释1处得到了<code>DecorView</code>，注释2处得到了<code>WindowManager</code>对象，注释3处调用<code>WindowManager</code>的<code>addView</code>方法，将<code>DecorView</code>作为参数传入，<code>WindowManager</code>的实现类是<code>WindowManagerImpl</code>，所以实际调用的是<code>WindowManagerImpl</code>的<code>addView</code>方法。再看<code>WindowManagerImpl</code>的<code>addView</code>方法：</p><blockquote><p>android.view.WindowManagerImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyTokens(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,</span><br><span class="line">            mContext.getUserId());<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处又调用了<code>WindowManagerGlobal</code>的<code>addView</code>方法：</p><blockquote><p>android.view.WindowManagerGlobal</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="params"><span class="function">        Display display, Window parentWindow, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    ...</span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    root.setView(view, wparams, panelParentView, userId);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>注释1处创建了<code>ViewRootImpl</code>实例赋值给<code>root</code>，注释2处将<code>DecorView</code>作为参数传入<code>ViewRootImpl</code>，完成了<code>DecorView</code>和<code>Window</code>的绑定。</p><p><code>ViewRootImpl</code>中还有个方法<code>performTraversals</code>，这个方法使<code>View</code>进入正真的工作流程：</p><blockquote><p>android.view.ViewRootImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    performLayout(lp, mWidth, mHeight);<span class="comment">//2</span></span><br><span class="line">    ...</span><br><span class="line">    performDraw();<span class="comment">//3</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>注释1处会执行<code>view</code>的<code>Measure</code>过程，注释2处会执行<code>view</code>的<code>Layout</code>过程，注释3处会执行<code>view</code>的<code>Draw</code>过程。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（五）熟悉又陌生的setContentView</title>
      <link href="/android/view/5-setContentView/"/>
      <url>/android/view/5-setContentView/</url>
      
        <content type="html"><![CDATA[<p>为什么说<code>setContentView</code>熟悉呢？因为该方法是我们从入门Android开发就接触的一个方法，在我们写过的每一个<code>Activity</code>中都有他的身影。但为什么又说<code>setContentView</code>陌生呢？因为我们在日常的开发中只知道用，并没有深入分析该方法是怎么将我们传入的<code>layout</code>资源<code>id</code>变为一个可视的界面的。今天我们就来揭开这层神秘的面纱，扒一扒其中的原理(<strong>注：源码基于Android12</strong>)。</p><p>因为我们日常开发的<code>Activity</code>最终都会继承自<code>android.app.Activity</code>，所以先看<code>Activity</code>类的<code>setContentView</code>方法：</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID); <span class="comment">//1</span></span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注释1处其实是调用了<code>getWindow()</code>的<code>setContentView</code>方法，我们再看<code>getWindow()</code>做了什么。</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回了一个<code>mWindow</code>，那<code>mWindow</code>又是什么，看他的声明代码：</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> Window mWindow;</span><br></pre></td></tr></table></figure><p><code>mWindow</code>是一个<code>Window</code>类，查看源码在<code>Activity</code>的<code>attach</code>方法中<code>mWindow</code>被赋值：</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="params"><span class="function">            Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="params"><span class="function">            Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="params"><span class="function">            CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="params"><span class="function">            NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="params"><span class="function">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="params"><span class="function">            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,</span></span></span><br><span class="line"><span class="params"><span class="function">            IBinder shareableActivityToken)</span> </span>&#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">        mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">        mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>看到这里，我们知道<code>Activity</code>的<code>setContentView</code>最终调用的是<code>PhoneWindow</code>的<code>setContentView</code>方法，我们继续看<code>PhoneWindow</code>的<code>setContentView</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释1处的<code>installDecor</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDecor = generateDecor(-<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">            mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mContentParent = generateLayout(mDecor);<span class="comment">//2</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>看注释1处的<code>generateDecor</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generateDecor</code>最终<code>new</code>了一个<code>DecorView</code>对象，并把该对象返回并赋值给<code>installDecor</code>方法中的<code>mDecor</code>引用。</p><p>返回到<code>installDecor</code>方法继续看注释2的<code>generateLayout</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    ...</span><br><span class="line">    layoutResource = R.layout.screen_title;</span><br><span class="line">    ...</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br></pre></td></tr></table></figure><p>由于<code>generateLayout</code>的代码很长，此处只贴出关键的代码。<code>generateLayout</code>的主要工作是将系统中的<code>R.layout.screen_title</code>布局资源添加到<code>DecorView</code>中，然后在<code>PhoneWindow</code>中调用<code>findViewById(ID_ANDROID_CONTENT)</code>，找到<code>R.layout.screen_title</code>中<code>id</code>为<code>ID_ANDROID_CONTENT</code>的<code>FrameLayout</code>，并返回给<code>installDecor</code>方法中的<code>mContentParent</code>引用。<br><code>R.layout.screen_title</code>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Popout bar for action modes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;?android:attr/windowTitleSize&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;?android:attr/windowTitleBackgroundStyle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/title&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">&quot;?android:attr/windowTitleStyle&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fadingEdge</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dip&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意最下面的<code>FrameLayout</code>的<code>id</code>是为：<code>content</code>，再看源码中的<code>ID_ANDROID_CONTENT</code>的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ID_ANDROID_CONTENT = com.android.internal.R.id.content;</span><br></pre></td></tr></table></figure><p>最后再回到<code>PhoneWindow</code>的<code>setContentView</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处的代码之前已经讲完了，然后看注释2处的代码，这句代码就是将<code>setContentView</code>传入的布局资源<code>id</code>加载到<code>mContentParent</code>，而<code>mContentParent</code>就是之前讲过的<code>id</code>为<code>content</code>的<code>FrameLayout</code>。</p><p>至此一个<code>Activity</code>的结构也清楚了，结构如下图所示：</p><p><img src="https://pic.imgdb.cn/item/61efb07a2ab3f51d915e2ede.jpg"></p><p><code>Activity</code>中包含一个<code>PhoneWindow</code>，<code>PhoneWindow</code>中包含一个<code>DecorView</code>，<code>DecorView</code>中包含系统的布局资源<code>R.layout.screen_title</code>。而<code>setContentView</code>就是将在<code>Activity</code>中传入的布局资源文件加载到<code>id</code>为<code>content</code>的<code>FrameLayout</code>中。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（四）深入理解事件分发机制</title>
      <link href="/android/view/4-event-2/"/>
      <url>/android/view/4-event-2/</url>
      
        <content type="html"><![CDATA[<p>上篇文章<a href="https://droidyu.github.io/android/view/3-event/">《View体系（三）初探View事件分发机制》</a>对View的事件分发机制进行了粗略的讲解，并用代码实际探究了View事件的传递和处理过程。这篇文章就对View的事件分发机制进行一个更深入的讲解。<br>之前提到过事件分发机制中的三个方法：<code>dispatchTouchEvent(MotionEvent event)</code>、<code>onInterceptTouchEvent(MotionEvent ev)</code>和<code>onTouchEvent(MotionEvent event)</code>，那么这三个方法到底有什么样的关联呢？他们的关系其实可以用如下的伪代码表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</span><br><span class="line">        result = onTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件由上到下的传递规则"><a href="#事件由上到下的传递规则" class="headerlink" title="事件由上到下的传递规则"></a>事件由上到下的传递规则</h1><p>对于根<code>ViewGroup</code>，事件首先传递给它的<code>dispatchTouchEvent()</code>方法，如果该<code>ViewGroup</code>的<code>onInterceptTouchEvent()</code>方法返回<code>true</code>，则表示它要拦截这个事件，这个事件就会交给它的<code>onTouchEvent()</code>方法处理，如果<code>onInterceptTouchEvent()</code>方法返回<code>false</code>，则表示它不拦截这个事件，则交给它的子元素的<code>dispatchTouchEvent()</code>来处理，如此的反复下去。如果传递给最底层的<code>View</code>，<code>View</code>是没有子<code>View</code>的，就会调用<code>View</code>的<code>dispatchTouchEvent()</code>方法，一般情况下最终会调用<code>View</code>的<code>onTouchEvent()</code>方法。</p><p>类比生活中的场景：假如你只是公司的基层员工(<code>View</code>),部门经理(父<code>ViewGroup</code>)通常会将事情(<code>MotionEvent</code>)安排给项目经理(子<code>ViewGroup</code>)，项目经理再将事情安排给你。如果项目经理觉得他自己就能处理部门经理安排的事情，他就会把事情拦截(<code>onInterceptTouchEvent</code>)，然后自己处理(<code>onTouchEvent</code>)，不再安排给你处理。</p><h1 id="事件由下而上的传递规则"><a href="#事件由下而上的传递规则" class="headerlink" title="事件由下而上的传递规则"></a>事件由下而上的传递规则</h1><p>事件传给最底层的<code>View</code>，如果他的<code>onTouchEvent()</code>方法返回<code>true</code>，则事件由最底层的<code>View</code>处理并消耗了，如果返回<code>false</code>则表示该<code>View</code>不消耗此次事件，则继续向上传递给父<code>View</code>的<code>onTouchEvent()</code>处理，如果父<code>View</code>的<code>onTouchEvent()</code>仍旧返回<code>false</code>，则继续向上传递给该父<code>View</code>的父<code>View</code>的<code>onTouchEvent()</code>处理，如此的反复下去。</p><p>同样类比上述场景：你把事情处理好了(<code>onTouchEvent</code>返回<code>true</code>)，那么事情就完结了；如果你处理不了(<code>onTouchEvent</code>返回<code>false</code>)，就需要上交给项目经理处理(传递给子<code>ViewGroup</code>的<code>onTouchEvent</code>)，如果项目经理也处理不了，就需要再向上交给部门经理处理(传递给父<code>ViewGroup</code>的<code>onTouchEvent</code>)。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（三）初探View事件分发机制</title>
      <link href="/android/view/3-event/"/>
      <url>/android/view/3-event/</url>
      
        <content type="html"><![CDATA[<p>事件分发机制，简而言之就是Android对触摸事件的一系列传递和处理的机制。在了解分发机制之前需要对下面三个方法有个大概的了解：</p><ul><li><code>public boolean dispatchTouchEvent(MotionEvent event)</code></li></ul><p>用来进行事件的分发。如果有事件传递给当前<code>View</code>，那么此方法一定会被调用。返回值受当前View的<code>onTouchEvent(MotionEvent event)</code>和子<code>View</code>的<code>dispatchTouchEvent(MotionEvent event)</code>方法的影响，表示是否消耗当前事件。</p><ul><li><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></li></ul><p>用来判断是否拦截事件，返回值表示是否拦截当前事件。</p><ul><li><code>public boolean onTouchEvent(MotionEvent event)</code></li></ul><p>用来处理事件，返回值表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前<code>View</code>无法再次接收到事件。</p><p>我们知道Android的<code>View</code>结构是树状结构的，<code>View</code>可以放在一个<code>ViewGroup</code>里，这个<code>ViewGroup</code>又可以放在一个<code>ViewGroup</code>里，那么当我们点击一个嵌套的结构，事件传递是怎样的呢？<br>为此，我们用代码来实现一下。</p><p>1.创建<code>BaseViewGroup</code>作为底层<code>ViewGroup</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseViewGroup</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseViewGroup</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;BaseViewGroup-dispatchTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;BaseViewGroup-onInterceptTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;BaseViewGroup-onTouchEvent-&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建<code>TopViewGroup</code>作为顶层<code>ViewGroup</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopViewGroup</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopViewGroup</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;TopViewGroup-dispatchTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;TopViewGroup-onInterceptTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;TopViewGroup-onTouchEvent-&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建<code>MyView</code>作为最上层的<code>View</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;MyView-dispatchTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;MyView-onTouchEvent-&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.布局自定义<code>View</code>及<code>ViewGroup</code>，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.droidyu.viewsystem._3_event.BaseViewGroup</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#1f1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;._3_event.ViewEventActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.droidyu.viewsystem._3_event.TopViewGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#ff1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;300dp&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.droidyu.viewsystem._3_event.MyView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;#f11&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.droidyu.viewsystem._3_event.TopViewGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.droidyu.viewsystem._3_event.BaseViewGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终，视图结构如下所示：<br><img src="https://pic.imgdb.cn/item/61f3e5de2ab3f51d91264e07.png"></p><p>运行程序，点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3efef2ab3f51d9131f00c.jpg"><br>从<code>Log</code>日志可以看出，正常情况下，<br>事件的传递顺序是：<br><code>BaseViewGroup</code> -&gt; <code>TopViewGroup</code> -&gt; <code>MyView</code> 的<code>dispatchTouchEvent</code>和<code>onInterceptTouchEvent</code>方法<br>事件处理顺序是：<br><code>MyView</code> -&gt; <code>TopViewGroup</code> -&gt; <code>BaseViewGroup</code> 的<code>onTouchEvent</code>方法</p><p>此时将<code>BaseViewGroup</code>的<code>onInterceptTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f0262ab3f51d91323696.jpg"><br>从<code>Log</code>日志可以看出，<code>BaseViewGroup</code>拦截事件之后，就直接处理事件，不会再将事件向子<code>View</code>传递。</p><p>还原代码，将<code>TopViewGroup</code>的<code>onInterceptTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f04c2ab3f51d913266fb.jpg"><br>从<code>Log</code>日志可以看出，事件从<code>BaseViewGroup</code>传递到<code>TopViewGroup</code>，<code>TopViewGroup</code>拦截事件之后，就直接处理事件，不会再将事件向子<code>View</code>传递，处理后会不消耗，返回给<code>BaseViewGroup</code>再处理。</p><p>还原代码，将<code>MyView</code>的<code>onTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f0952ab3f51d9132c2af.jpg"><br>从<code>Log</code>日志可以看出，事件传递到<code>MyView</code>，<code>MyView</code>处理事件之后，就不再向上传递。</p><p>还原代码，将<code>TopViewGroup</code>的<code>onTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f0e62ab3f51d913323f9.jpg"><br>从<code>Log</code>日志可以看出，事件传递到<code>MyView</code>，<code>MyView</code>处理事件之后，又向上传递到<code>TopViewGroup</code>处理，<code>TopViewGroup</code>处理事件之后，就不再向上传递。</p><p>至此相信你对<code>View</code>的事件传递和处理有了一个更直观的认识，更多的讲解将在后续文章中更新，敬请期待。。。</p><p>源码见<a href="https://github.com/droidYu/view-system">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（二）View滑动的六种方式</title>
      <link href="/android/view/2-scroll/"/>
      <url>/android/view/2-scroll/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中，有时会遇到需要对View进行滑动处理的情况，今天我们就一起来看一下如何实现View的滑动。</p><p>不管采用什么方式，实现思路基本是一致的：当触摸到View时，记下当前触摸点的坐标；当手指移动时，记下移动后触摸点的坐标，然后用两个坐标算出移动的偏移量，再利用偏移量来修改View的坐标。</p><p>下面分别来讲解实现View滑动的6种方式。</p><h1 id="一、layout"><a href="#一、layout" class="headerlink" title="一、layout()"></a>一、layout()</h1><p><code>layout()</code>方法是View在进行布局流程时调用的一个方法，我们可以在移动View时调用次方法，不断的进行View的布局，达到滑动View的目的。具体过程如下：</p><p>（1）先自定义一个View，重写<code>onTouchEvent(MotionEvent event)</code>方法，在<code>ACTION_DOWN</code>时获取按下时的坐标。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>（2）在手指移动时，计算偏移量并调用<code>layout()</code>方法进行重新布局。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">                <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">                way1(offsetX, offsetY);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中<code>way1()</code>方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way1</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    layout(getLeft() + offsetX,</span><br><span class="line">            getTop() + offsetY,</span><br><span class="line">            getRight() + offsetX,</span><br><span class="line">            getBottom() + offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、offsetLeftAndRight-与offsetTopAndBottom"><a href="#二、offsetLeftAndRight-与offsetTopAndBottom" class="headerlink" title="二、offsetLeftAndRight()与offsetTopAndBottom()"></a>二、offsetLeftAndRight()与offsetTopAndBottom()</h1><p>这两个方法的使用与效果和<code>layout()</code>方法差不多，将<code>ACTION_MOVE</code>中的代码替换为<code>way2()</code>即可，其中<code>way2()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way2</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    offsetLeftAndRight(offsetX);</span><br><span class="line">    offsetTopAndBottom(offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、LayoutParams"><a href="#三、LayoutParams" class="headerlink" title="三、LayoutParams"></a>三、LayoutParams</h1><p><code>LayoutParams</code>保存了View的布局参数，因此我们可以通过改变布局参数的值来改变View的位置。将<code>ACTION_MOVE</code>中的代码替换为<code>way3_1()</code>即可，其中<code>way3_1()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way3_1</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) getLayoutParams();</span><br><span class="line">    layoutParams.leftMargin = getLeft() + offsetX;</span><br><span class="line">    layoutParams.topMargin = getTop() + offsetY;</span><br><span class="line">    setLayoutParams(layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为父控件是<code>LinearLayout</code>，所以用了<code>LinearLayout.LayoutParams</code>，除了使用布局的<code>LayoutParams</code>，还可以使用<code>ViewGroup.MarginLayoutParams</code>来改变View的位置。将<code>ACTION_MOVE</code>中的代码替换为<code>way3_2()</code>即可，其中<code>way3_2()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way3_2</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();</span><br><span class="line">    layoutParams.leftMargin = getLeft() + offsetX;</span><br><span class="line">    layoutParams.topMargin = getTop() + offsetY;</span><br><span class="line">    setLayoutParams(layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、scrollTo与scrollBy"><a href="#四、scrollTo与scrollBy" class="headerlink" title="四、scrollTo与scrollBy"></a>四、scrollTo与scrollBy</h1><p><code>scollTo(x,y)</code>表示移动到一个具体的坐标点，而<code>scollBy(dx,dy)</code>则表示移动的增量为<code>dx</code>、<code>dy</code>。其中<code>scollBy</code>最终也是要调用<code>scollTo</code>的。<code>scollTo</code>、<code>scollBy</code>移动的是View的内容，如果在ViewGroup中使用则是移动他所有的子View。将<code>ACTION_MOVE</code>中的代码替换为<code>way4()</code>即可，其中<code>way4()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way4</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    ((View) getParent()).scrollBy(-offsetX, -offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要实现View随着我们手指移动的效果的话，我们就需要将偏移量设置为负值。</p><h1 id="五、Scroller"><a href="#五、Scroller" class="headerlink" title="五、Scroller"></a>五、Scroller</h1><p><code>Scroller</code>本身是不能实现View的滑动的，它需要配合View的<code>computeScroll()</code>方法才能弹性滑动的效果。</p><h2 id="（1）初始化Scroller"><a href="#（1）初始化Scroller" class="headerlink" title="（1）初始化Scroller"></a>（1）初始化<code>Scroller</code></h2><p>在构造函数中初始化<code>Scroller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyScrollView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    scroller = <span class="keyword">new</span> Scroller(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（2）重写computeScroll"><a href="#（2）重写computeScroll" class="headerlink" title="（2）重写computeScroll()"></a>（2）重写<code>computeScroll()</code></h2><p>系统会在绘制View的时候在<code>draw()</code>方法中调用该方法，这个方法中我们调用父类的<code>scrollTo()</code>方法并通过<code>Scroller</code>来不断获取当前的滚动值，每滑动一小段距离我们就调用<code>invalidate()</code>方法不断的进行重绘，重绘就会调用<code>computeScroll()</code>方法，这样我们就通过不断的移动一个小的距离并连贯起来就实现了平滑移动的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (scroller.computeScrollOffset()) &#123;</span><br><span class="line">        ((View) getParent()).scrollTo(scroller.getCurrX(), scroller.getCurrY());</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（3）调用Scroller-startScroll-方法"><a href="#（3）调用Scroller-startScroll-方法" class="headerlink" title="（3）调用Scroller.startScroll()方法"></a>（3）调用<code>Scroller.startScroll()</code>方法</h2><p>我们在<code>MyScrollView</code>中写一个<code>smoothScrollTo()</code>方法，调用<code>Scroller.startScroll()</code>方法，在<code>2000</code>毫秒内沿X轴和Y轴移动x和y个像素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> scrollY = getScrollY();</span><br><span class="line">    <span class="keyword">int</span> offsetX = scrollX - x;</span><br><span class="line">    <span class="keyword">int</span> offsetY = scrollY - y;</span><br><span class="line">    scroller.startScroll(scrollX, scrollY, offsetX, offsetY, <span class="number">2000</span>);</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（4）调用MyScrollView的smoothScrollTo-方法"><a href="#（4）调用MyScrollView的smoothScrollTo-方法" class="headerlink" title="（4）调用MyScrollView的smoothScrollTo()方法"></a>（4）调用<code>MyScrollView</code>的<code>smoothScrollTo()</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.smoothScrollTo(<span class="number">200</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><h1 id="六、属性动画"><a href="#六、属性动画" class="headerlink" title="六、属性动画"></a>六、属性动画</h1><p>最后就是定义一个属性动画进行View的滑动，属性动画的具体使用将放在后续章节中进行讲解，这里直接贴出实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">&quot;translationX&quot;</span>, <span class="number">400</span>);</span><br><span class="line">animator.setDuration(<span class="number">2000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><p>源码见<a href="https://github.com/droidYu/view-system/tree/main/app/src/main/java/com/droidyu/viewsystem/_2_scroll">Github</a></p><p>参考文献：<br>《Android进阶之光》<br>《Android开发艺术探索》</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（一）基础知识</title>
      <link href="/android/view/1-basic/"/>
      <url>/android/view/1-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="View-及ViewGroup"><a href="#View-及ViewGroup" class="headerlink" title="View 及ViewGroup"></a>View 及ViewGroup</h1><p>在Android中，常用控件可大致分为两大类：<code>View</code>与<code>ViewGroup</code>。<code>ViewGroup</code>可包含多个<code>View</code>及<code>ViewGroup</code>，形成一个树状结构。需要注意的是<code>ViewGroup</code>也继承自<code>View</code>。View及ViewGroup组织结构如下：<br><img src="https://pic.imgdb.cn/item/61f22a542ab3f51d91780c5e.png"></p><h1 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h1><p>在Android中有两种坐标系：Android坐标系和View坐标系。了解坐标系是对View进行更多操作的基础。</p><h2 id="Android坐标系"><a href="#Android坐标系" class="headerlink" title="Android坐标系"></a>Android坐标系</h2><p>以屏幕左上角为原点，原点向右为<code>X</code>轴正方向，原点向下为<code>Y</code>轴正方向。在触控事件中，<code>getRawX()</code>、<code>getRawY()</code>获取的坐标也是Android坐标系的坐标。</p><p><img src="https://pic.imgdb.cn/item/61efa6722ab3f51d91557262.jpg"></p><h2 id="View坐标系"><a href="#View坐标系" class="headerlink" title="View坐标系"></a>View坐标系</h2><p>View坐标系是以View为基础的坐标系，搞清楚下图的关系也就清楚了View坐标系。<br><img src="https://pic.imgdb.cn/item/61efa6802ab3f51d91557ee0.jpg"></p><p>下面解释一下上图中涉及到的各个方法。<br>其中下面4个方法可在View中直接获取：</p><ul><li><code>getTop()</code>：获取View顶边到父View顶边的距离</li><li><code>getBottom()</code>：获取View底边到父View顶边的距离</li><li><code>getLeft()</code>：获取View左边到父View左边的距离</li><li><code>getRight()</code>：获取View右边到父View左边的距离</li></ul><p>剩余4个方法需要在View有触摸事件发生时，通过onTouchEvent(MotionEvent event)方法中的event获取：</p><ul><li><code>getX()</code>：触摸点到View左边的距离</li><li><code>getY()</code>：触摸点到View顶边的距离</li><li><code>getRawX()</code>：触摸点到屏幕左边的距离</li><li><code>getRawY()</code>：触摸点到屏幕顶边的距离</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top = getTop();</span><br><span class="line">    <span class="keyword">int</span> bottom = getBottom();</span><br><span class="line">    <span class="keyword">int</span> left = getLeft();</span><br><span class="line">    <span class="keyword">int</span> right = getRight();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        <span class="keyword">float</span> rawX = event.getRawX();</span><br><span class="line">        <span class="keyword">float</span> rawY = event.getRawY();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码见<a href="https://github.com/droidYu/view-system/tree/main/app/src/main/java/com/droidyu/viewsystem/_1_basic">Github</a></p><p>参考文献：<br>《Android进阶之光》<br>《Android开发艺术探索》</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
